


package eg.edu.alexu.csd.datastructure.stack.cs41;

import java.util.Scanner;
import java.util.*;



/**
 * main class for the user interface
 *
 */
public class call {

	public static void main(String[] args)  {
		implement y = new implement();
				
		int x ;
		Scanner t= new Scanner (System.in);
		Object r;
		int w;
		boolean m;
		boolean b=true;
		while(b==true) {
			System.out.println("Enter the operation you want: ");
			System.out.println("1: Push");
			System.out.println("2: Pop");
			System.out.println("3: Peek");
			System.out.println("4: Get size");
			System.out.println("5: Check if empty");	
			System.out.println("6: End stack operations ");		
			x= t.nextInt();	
			
			
		if(x==1) {
			System.out.println("Enter the element you want to push : ");
			y.push(t.nextInt());
		}
		else if(x==2) {
			try {
			r=y.pop();
			System.out.println(r);
			}catch( Exception e) {
				System.out.println("Stack is empty. ");
			}
			
		}
		else if(x==3) {
			try {
			r=y.peek();
			System.out.println(r);
			}catch(Exception e) {
				
			}
		}
		else if(x==4) {
			
		w=y.size;
		System.out.println(w);
		}
		
		
		else if(x==5) {
			m=y.isEmpty();
			System.out.println(m);
		}
		else if (x==6) {
			b=false ;
		}
		else {
			try {
				throw new Exception ("invalid number");
			} catch (Exception e) {				
				
			}
		}

	}
			

}
}









package eg.edu.alexu.csd.datastructure.stack.cs41;

public interface IStack {
	
	
	public Object pop() ;
		
	public Object peek() ;
	
	public void push(Object element);
	
	public boolean isEmpty();
		
	public int size();

}






package eg.edu.alexu.csd.datastructure.stack.cs41;

public class implement implements IStack {
	
	node top;
	int size;
	
	/**
	* Set the top =null and size =0 indicating that the stack is empty at the start.
	*
	* 
	*/
	public implement (){
		top=null;
		size =0;
		
	}
	
	/**
	* Removes the object at top of stack and returns that object .
	*
	* @return the top of stack object, or through exception if the stack is empty
	*/
	
	public Object pop()   {
		if(isEmpty()) {
			
				try {
					throw new Exception(" Stack is empty.");
				} catch (Exception e) {
					
				}							
		}
		
		Object temp=top.getValue();
		top=top.getNext();
		size--;
		return temp;
		
	}
	
	/**
	* Get the object at  top of stack without removing it from the stack.
	*
	* @return top of stack object, or through exception if the stack is empty
	*/
	
	
	public Object peek()   {
		if(isEmpty()) {
					try {
						throw new Exception(" Stack is empty.");
					} catch (Exception e) {
					
					}			
			
		}
		return top.getValue();
		
	}
	
	
	/**
	* Pushes an element onto the top of the stack.
	*
	* @param object
	* to insert
	*/
	
	
	public void push(Object element) {
		
		node x = new node(element , top);
		top=x;
		size++;
	}
	public void print() {
		node q=top;
		while(q!=null) {
			System.out.println(q.getValue());
			q=q.getNext();
			
		}
	}
	
	
	
	/**
	* Tests if the stack is empty or not
	*
	* @return true if stack empty , false if the stack is not empty
	*/
	public boolean isEmpty() {
		
		if(top==null) {
			return true;
		}
		return false ;
	}
	
	
	
	/**
	* Returns the number of elements in the stack.
	*
	* @return number of elements in the stack
	*/
	
	public int size() {
		return size;
	}
	
	

private class node {
	
	node top;
	node next;
	Object value;
	
	/**
	* creates a new node with the given value and the given address of the next to it.
	*
	* @param object (value of the node)
	* @param node(pointer to the next node of current node)
	*/
	public node(Object val , node r) {
		this.value=val;
		this.next=r;
		
	}
	
	/**
	* get the value in this node (Data field).
	*
	* @return the value in the node
	*/
	
	public Object getValue() {
		return value ;		
	}
	
	
	/**
	* get the address of the next node to current node ,or get a pointer to next node
	*
	* @return pointer to next node
	*/
	
	public node getNext() {
		return next ;
	}
	
	/**
	* Set a new value to the node.
	*
	* @param object (the new value)
	*/
	public void setvalue(Object k) {
		value=k;
	}
	
	
	/**
	* Set a new addres of the next node to current node  
	*
	* @param node (parameter to the new next node)
	* to insert
	*/
	public void setnext(node w) {
		next = w;
	}

}

}






package eg.edu.alexu.csd.datastructure.stack.cs41;

public interface IExpressionEvaluator {
	
	public String infixToPostfix(String expression);
	
	public int evaluate(String expression);

}





package eg.edu.alexu.csd.datastructure.stack.cs41;




/**
 * class to implement the interface IExpressionEvaluator
 */

public class application implements IExpressionEvaluator {
	implement a= new implement();
	
	
	
	/**
	* Takes a symbolic and numeric infix expression as input(given) and converts it to
	* postfix expression.
	* it is not necessary that the length of the term be 1 
	* @param  the infix expression
	* @return  (string f) the postfix expression , or throw exception if the original expression was unbalanced (not matched Parenthesis)
	*/
	
	public String infixToPostfix(String expression) {
		
		/**
		 * f is a string value to store the postfix expression and return it
		 */
		String f="";
		int x=0;
		int y=0;
		boolean v=true;
		boolean b=isParenthesisMatch(expression);
		if(b==false){
			try {
				throw new Exception (" Error:the original expression was unbalanced. ");
			} catch (Exception e) {
				System.out.println(" Error:the original expression was unbalanced. ");
			}
		}
		
		for(int i=0;i<expression.length();) {
			if((expression.charAt(i)>='a'&&expression.charAt(i)<='z')||(expression.charAt(i)>='A'&&expression.charAt(i)<='Z')&&expression.charAt(i)!=' ') {
				f+=expression.charAt(i);
				f+=" ";
				i++;
				
			}else {
				if(expression.charAt(i)==' ') {
					i++;
				
				}else {
				if(a.isEmpty()&&expression.charAt(i)!='('&&expression.charAt(i)!='[') {
					a.push(expression.charAt(i));
					i++;
					
				}
				else {
				if(expression.charAt(i)!='('&&expression.charAt(i)!='[') {
					x=order(expression.charAt(i));
					y=order((char) a.peek());
					if(x<y) {
						a.push(expression.charAt(i));
						i++;
						if(i>=expression.length()) {
							break;
						}
					}else {
						v=a.isEmpty();
						if(v==false) {
						f+=a.pop();
						f+=" ";
						}
						a.push(expression.charAt(i));
						i++;
					
					}
										
				}else  {
					a.push(expression.charAt(i));
					int r=i;
					int p=0;
					i++;
					while(expression.charAt(i)!=')'&&expression.charAt(i)!=']') {
						if((expression.charAt(i)>='a'&&expression.charAt(i)<='z')||(expression.charAt(i)>='A'&&expression.charAt(i)<='Z')&&expression.charAt(i)!=' ') {
							f+=expression.charAt(i);
							f+=" ";
							i++;
							p++;
						} else if(expression.charAt(i)=='('||expression.charAt(i)=='[') {
							a.push(expression.charAt(i));
							int g=0;
							int e=i;
							i++;
							while(expression.charAt(i)!=')'&&expression.charAt(i)!=']') {
								if((expression.charAt(i)>='a'&&expression.charAt(i)<='z')||(expression.charAt(i)>='A'&&expression.charAt(i)<='Z')&&expression.charAt(i)!=' ') {
									f+=expression.charAt(i);
									f+=" ";
									i++;
									g++;
								}	else {
									if(expression.charAt(i)==' ') {
										i++;
										g++;
									}else {
										if(i==(e+g+1)&&expression.charAt(i)!='('&&expression.charAt(i)!='['&&expression.charAt(i)!=')'&&expression.charAt(i)!=']') {
										a.push(expression.charAt(i));
										i++;
										if(i>=expression.length()) {
											break;
										}
										}else {
										x=order(expression.charAt(i));
										y=order((char) a.peek());
										if(x<y&&expression.charAt(i)!='('&&expression.charAt(i)!='['&&expression.charAt(i)!=')'&&expression.charAt(i)!=']') {
											a.push(expression.charAt(i));
											i++;
										}else {
											v=a.isEmpty();
											int o=1;
											while(o==1&&v==false) {
											f+=a.pop();
											f+=" ";	
											v=a.isEmpty();
											if(v==false) {
											x=order(expression.charAt(i));
											y=order((char) a.peek());
											if(x<y||(char)a.peek()=='('||(char)a.peek()=='[') {
												o=0;
											}else {
												o=1;
											}
											}
											}
											a.push(expression.charAt(i));
											i++;
										}
										}
									}
										}
								
							}
							char t=(char) a.peek();
							while(t!='('&&t!='[') {
							v=a.isEmpty();
							if(v==false) {
							f+=a.pop();
							f+=" ";
							}					
								t=(char) a.peek();						
							}
							a.pop();
							i++;
							
						}
						else {
					if(expression.charAt(i)==' ') {
						i++;
						if(i>=expression.length()) {
							break;
						}
						p++;
					}else {
						if(i==(r+p+1)&&expression.charAt(i)!='('&&expression.charAt(i)!='['&&expression.charAt(i)!=')'&&expression.charAt(i)!=']') {
						a.push(expression.charAt(i));
						i++;
						}else {
						x=order(expression.charAt(i));
						y=order((char) a.peek());
						if(x<y&&expression.charAt(i)!='('&&expression.charAt(i)!='['&&expression.charAt(i)!=')'&&expression.charAt(i)!=']') {
							a.push(expression.charAt(i));
							i++;
						}else {
							v=a.isEmpty();
							int o=1;
							while(o==1&&v==false) {
							f+=a.pop();
							f+=" ";	
							v=a.isEmpty();
							if(v==false) {
							x=order(expression.charAt(i));
							y=order((char) a.peek());
							if(x<y||(char)a.peek()=='('||(char)a.peek()=='[') {
								o=0;
							}else {
								o=1;
							}
							}
							}
							a.push(expression.charAt(i));
							i++;
						}
						}
					}
						}
					}
					char u=(char) a.peek();
					while(u!='('&&u!='[') {
					v=a.isEmpty();
					if(v==false) {
					f+=a.pop();
					f+=" ";
					}					
						u=(char) a.peek();						
					}
					a.pop();
					i++;
					if(i>=expression.length()) {
						break;
					}
										
				}
				
				
				}
				
			}
			}		
						
		}		
		v=a.isEmpty();
		while(v==false) {
		f+=a.pop();
		v=a.isEmpty();
		if(v==false) {
			f+=" ";
		}
		
		
		}
	
		
		return f;
	}
	
	
	
	
	
	
	/**
	* Evaluate a postfix numeric expression, with a single space separator between terms
	* @param the postfix expression
	* @return  (int n)the expression evaluated value , or throw exception if there is an operator insted of + or - or * or /
	*/
	
	public int evaluate(String expression) {
		int total;		
		int no1,no2;
		int len = expression.length();
		int d=0;
		int q=0;
		int j=1;
		int t=0;
		int k=1;
		int p=0;
		for(int l =0;l<expression.length();l++) {
			if(expression.charAt(l)!='+'&&expression.charAt(l)!='-'&&expression.charAt(l)!='/'&&expression.charAt(l)!='*'&&expression.charAt(l)!=' '&&!IsNumber(expression.charAt(l))) {
				try {
					throw new Exception ("Error: invalid operators");
				} catch (Exception e) {
					
				}
			}
		}
		boolean  v= true;
		for(int i=0;i<len;) {
			d=0;
			j=0;
			q=0;
			k=1;
			if(expression.charAt(i)==' ') {
				i++;
			}
			else {
			if(expression.charAt(i)=='+'||expression.charAt(i)=='-'||expression.charAt(i)=='*'||expression.charAt(i)=='/'||IsNumber(expression.charAt(i))) {
				if(IsNumber(expression.charAt(i))) {
					t=i;
					while(expression.charAt(i)!=' ') {
						j++;
						i++;
					}
					int[] arr=new int  [j];
					for( p=0;p<j;p++) {
						arr[p]=expression.charAt(t)-'0';
						t++;
					}
					for( p=j-1;p>=0;p--) {
						d+=arr[p]*k;
						k*=10;
					}
					a.push(d);
				}else if(expression.charAt(i)=='-'&&expression.charAt(i+1)!=' ') {
					
					i++;
					t=i;
					while(expression.charAt(i)!=' ') {
						j++;
						i++;
					}
					int [] arr=new int  [j];
					for( p=0;p<j;p++) {
						arr[p]= expression.charAt(t)-'0';
						t++;
					}
					for( p=j-1;p>=0;p--) {
						q+=arr[p]*k;
						k*=10;
					}
					q=-q;
					a.push(q);
					  }
				
					  else {
					v=a.isEmpty();
					if(v==false) {
						no2= (int)a.pop();
						no1=(int) a.pop();
						switch (expression.charAt(i)) {
						   case '+' :
						    total=no1 + no2 ;
						    a.push(total);
						    i++;
						    break;
						    case  '-' :
							total=no1 - no2 ;
							a.push(total);
							i++;
							break ;
							case '*' :
							total=no1 * no2 ;
							a.push(total);
							i++;
							break;
							case  '/' :
							total=no1 / no2 ;
							a.push(total);
							i++;
							break;												
					}
						
				}
			}
					  
				}
			}
		}
		
		
		
		/**
		 * int n is the final value that would be returned
		 */
	   int n= (int) a.pop();
	   return  n;
		
	}
	
	
	/**
	* checks if the given char is number or not
	*
	* @param char 
	* @return true if the character is number , false if it is not a number
	*/


	private boolean IsNumber(char charAt) {
		if(charAt<'0'||charAt>'9') {
		return false;
		}
		return true ;
	}
	
	
	
	/**
	* define the order of operators 
	* @param char (the operator)
	* @return int (integer tells the operator order and Precedence  from 1 to 10)
	* (e.g., if the operator has  the highest piriority then the method returns the least number which is 1)    
	*/
	
	
	private int order(char x) {
		if(x=='('||x=='['||x=='.') {
			return 1;
		}else if(x=='!') {
			return 2;
		}else if(x=='*'||x=='/'||x=='%') {
			return 3;
		}else  if(x=='+'||x=='-') {
			return 4;
		}else if(x=='<'||x=='>') {
			return 5;
		}else if(x=='&') {
			return 6;
		}else if(x=='^') {
			return 7;
		}else if(x=='|') {
			return 8;
		}else if(x=='=') {
			return 9;
		}else if(x==',') {
			return 10;
		}
		return 0;
	}
	
	
	
	/**
	* checks if the infix expression is balanced or not (all the Parenthesis in it is matched or not) 
	*
	* @param string (the infix expression)
	* @return true if the infix expression is balanced , false if not
	*/
	
	
	public static boolean isParenthesisMatch(String str) {
		
		implement w =new implement();
	    if (str.charAt(0) == '[')
	        return false;

	    char c;
	    for(int i=0; i < str.length(); i++) {
	        c = str.charAt(i);

	        if(c == '(')
	            w.push(c);
	        else if(c == '[')
	            w.push(c);
	        else if(c == ')')
	            if(w.isEmpty())
	                return false;
	            else if((char)w.peek() == '(')
	                w.pop();
	            else
	                return false;
	        else if(c == ']')
	            if(w.isEmpty())
	                return false;
	            else if((char)w.peek() == '[')
	                w.pop();
	            else
	                return false;
	    }
	    return w.isEmpty();
	}
	
	


}













package eg.edu.alexu.csd.datastructure.stack.cs41;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

 class applicationTest {
	
	@Test
	
	public void application() {
		
		application a = new application();
		application b = new application();
		application c = new application();
		application d = new application();
		
		
		String g1="(a / (b - c + d)) * (e - a) * c";
		String g2="6 2 / 3 - 4 2 * +";
		String g3="24 3 + 3 +";
		String g4="a * b / c";
		 
		//My code answers are
		
		String a1=a.infixToPostfix(g1);
		int a2=b.evaluate(g2);
		int a3=c.evaluate(g3);
		String a4=d.infixToPostfix(g4);
		//Right answers are 
		
		String r1="a b c - d + / e a - * c *";
		String r2="a b * c /";
		
		assertEquals(r1,a1);
		assertEquals(8,a2);
		assertEquals(30,a3);
		assertEquals(r2,a4);
		
		
	}
	
	

}



